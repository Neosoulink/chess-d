import { Lifecycle, scoped } from "tsyringe";
import { Chess, Move } from "chess.js";

/**
 * @description Generated by Claude Opus 4.6
 * @author Claude
 * @version 4.6
 */
@scoped(Lifecycle.ContainerScoped)
export class BasicBotService {
	PIECE_VALUES: Record<string, number> = {
		p: 100,
		n: 320,
		b: 330,
		r: 500,
		q: 900,
		k: 20000
	};

	PAWN_TABLE = [
		0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 10, 10, 20, 30, 30,
		20, 10, 10, 5, 5, 10, 25, 25, 10, 5, 5, 0, 0, 0, 20, 20, 0, 0, 0, 5, -5,
		-10, 0, 0, -10, -5, 5, 5, 10, 10, -20, -20, 10, 10, 5, 0, 0, 0, 0, 0, 0, 0,
		0
	];

	KNIGHT_TABLE = [
		-50, -40, -30, -30, -30, -30, -40, -50, -40, -20, 0, 0, 0, 0, -20, -40, -30,
		0, 10, 15, 15, 10, 0, -30, -30, 5, 15, 20, 20, 15, 5, -30, -30, 0, 15, 20,
		20, 15, 0, -30, -30, 5, 10, 15, 15, 10, 5, -30, -40, -20, 0, 5, 5, 0, -20,
		-40, -50, -40, -30, -30, -30, -30, -40, -50
	];

	BISHOP_TABLE = [
		-20, -10, -10, -10, -10, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10, -10, 0,
		10, 10, 10, 10, 0, -10, -10, 5, 5, 10, 10, 5, 5, -10, -10, 0, 5, 10, 10, 5,
		0, -10, -10, 10, 10, 10, 10, 10, 10, -10, -10, 5, 0, 0, 0, 0, 5, -10, -20,
		-10, -10, -10, -10, -10, -10, -20
	];

	ROOK_TABLE = [
		0, 0, 0, 0, 0, 0, 0, 0, 5, 10, 10, 10, 10, 10, 10, 5, -5, 0, 0, 0, 0, 0, 0,
		-5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0,
		0, -5, -5, 0, 0, 0, 0, 0, 0, -5, 0, 0, 0, 5, 5, 0, 0, 0
	];

	QUEEN_TABLE = [
		-20, -10, -10, -5, -5, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10, -10, 0, 5,
		5, 5, 5, 0, -10, -5, 0, 5, 5, 5, 5, 0, -5, 0, 0, 5, 5, 5, 5, 0, -5, -10, 5,
		5, 5, 5, 5, 0, -10, -10, 0, 5, 0, 0, 0, 0, -10, -20, -10, -10, -5, -5, -10,
		-10, -20
	];

	KING_TABLE = [
		-30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50, -50, -40, -40,
		-30, -30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50, -50, -40,
		-40, -30, -20, -30, -30, -40, -40, -30, -30, -20, -10, -20, -20, -20, -20,
		-20, -20, -10, 20, 20, 0, 0, 0, 0, 20, 20, 20, 30, 10, 0, 0, 10, 30, 20
	];

	PST: Record<string, number[]> = {
		p: this.PAWN_TABLE,
		n: this.KNIGHT_TABLE,
		b: this.BISHOP_TABLE,
		r: this.ROOK_TABLE,
		q: this.QUEEN_TABLE,
		k: this.KING_TABLE
	};

	public evaluateBoard(game: Chess): number {
		if (game.isCheckmate()) {
			return game.turn() === "w" ? -99999 : 99999;
		}
		if (game.isDraw()) return 0;

		let score = 0;
		const board = game.board();

		for (let r = 0; r < 8; r++) {
			for (let c = 0; c < 8; c++) {
				const piece = board[r]?.[c];
				if (!piece) continue;

				const value = this.PIECE_VALUES[piece.type];
				const idx = piece.color === "w" ? r * 8 + c : (7 - r) * 8 + c;
				const positional = this.PST[piece.type]?.[idx];

				if (piece.color === "w") {
					score += (value ?? 0) + (positional ?? 0);
				} else {
					score -= (value ?? 0) + (positional ?? 0);
				}
			}
		}

		return score;
	}

	public orderMoves(game: Chess, moves: Move[]): Move[] {
		return moves.sort((a, b) => {
			let scoreA = 0,
				scoreB = 0;
			if (a.captured)
				scoreA +=
					(this.PIECE_VALUES[a.captured] ?? 0) -
					(this.PIECE_VALUES[a.piece] ?? 0) / 10;
			if (b.captured)
				scoreB +=
					(this.PIECE_VALUES[b.captured] ?? 0) -
					(this.PIECE_VALUES[b.piece] ?? 0) / 10;
			if (a.promotion) scoreA += this.PIECE_VALUES[a.promotion] ?? 0;
			if (b.promotion) scoreB += this.PIECE_VALUES[b.promotion] ?? 0;
			if (game.isCheck()) scoreA += 50;
			return scoreB - scoreA;
		});
	}

	public minimax(
		game: Chess,
		depth: number,
		alpha: number,
		beta: number,
		isMaximizing: boolean
	): number {
		if (depth === 0 || game.isGameOver()) {
			return this.evaluateBoard(game);
		}

		const moves = this.orderMoves(game, game.moves({ verbose: true }));

		if (isMaximizing) {
			let maxEval = -Infinity;
			for (const move of moves) {
				game.move(move);
				const eval_ = this.minimax(game, depth - 1, alpha, beta, false);
				game.undo();
				maxEval = Math.max(maxEval, eval_);
				alpha = Math.max(alpha, eval_);
				if (beta <= alpha) break;
			}
			return maxEval;
		} else {
			let minEval = Infinity;
			for (const move of moves) {
				game.move(move);
				const eval_ = this.minimax(game, depth - 1, alpha, beta, true);
				game.undo();
				minEval = Math.min(minEval, eval_);
				beta = Math.min(beta, eval_);
				if (beta <= alpha) break;
			}
			return minEval;
		}
	}

	public findBestMove(game: Chess, depth: number = 3): Move | null {
		const moves = game.moves({ verbose: true });
		if (moves.length === 0) return null;

		const isMaximizing = game.turn() === "w";
		let bestMove: Move | null = null;
		let bestEval = isMaximizing ? -Infinity : Infinity;

		const orderedMoves = this.orderMoves(game, moves);

		for (const move of orderedMoves) {
			game.move(move);
			const eval_ = this.minimax(
				game,
				depth - 1,
				-Infinity,
				Infinity,
				!isMaximizing
			);
			game.undo();

			if (isMaximizing) {
				if (eval_ > bestEval) {
					bestEval = eval_;
					bestMove = move;
				}
			} else {
				if (eval_ < bestEval) {
					bestEval = eval_;
					bestMove = move;
				}
			}
		}

		return bestMove;
	}
}
